from math import comb

import matplotlib.pyplot as plt
import numpy as np
from numba import jit

# ===============================================================
#                    –ü–ê–†–ê–ú–ï–¢–†–´ –ú–û–î–ï–õ–ò
# ===============================================================
N = 1000  # —á–∏—Å—Ç–æ —á–∞—Å—Ç–∏—Ü
L = 1.0  # –¥–ª–∏–Ω–∞ —Ä–µ–±—Ä–∞
r = 0.001  # —Ä–∞–¥–∏—É—Å —á–∞—Å—Ç–∏—Ü
# phi = N * (4/3) * pi * r^3 —Ñ–æ—Ä–º—É–ª–∞ –¥–ª—è –Ω–∞—Ö–æ–∂–¥–µ–Ω–∏—è –ø—Ä–æ—Ü–µ–Ω—Ç–∞ –≥–∞–∑–∞ –≤ –Ω–∞—à–µ–º –∫—É–±–µ –µ—Å–ª–∏ N = 1000 r = 0.01 —Ç–æ —ç—Ç–æ 4%
mass = 1.0
dt = 0.002  # —à–∞–≥ –∏–Ω—Ç–µ–≥—Ä–∏—Ä–æ–≤–∞–Ω–∏—è
steps_eq = 7000  # –≤—Ä–µ–º—è 1 —ç–∫—Å–ø–µ—Ä–µ–º–µ–Ω—Ç–∞ –Ω—É —Ç–∏–ø–∞ —á–∏—Å–ª–æ —à–∞–≥–æ–≤
steps_stat = 30000  # —Å–∫–æ–ª—å–∫–æ —Ç–æ—á–µ–∫ –¥–ª—è –≥–∏—Å—Ç–æ–≥—Ä–∞–º–º—ã –±–µ—Ä–µ–º

# ===============================================================
#           –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø –ö–û–û–†–î–ò–ù–ê–¢ (–±–µ–∑ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–π)
# ===============================================================
np.random.seed(42)  # –¥–ª—è –≤–æ—Å–ø—Ä–æ–∏–∑–≤–æ–¥–∏–º–æ—Å—Ç–∏
pos = np.random.rand(N, 3) * (L - 2 * r) + r  # –æ—Ç—Å—Ç—É–ø –æ—Ç —Å—Ç–µ–Ω–æ–∫


def ensure_no_overlap(pos, r):
    # pos —ç—Ç–æ —Å–ø–∏—Å–æ–∫ —Ñ–æ—Ä–º—ã (N, 3), –≥–¥–µ:
    # N ‚Äî —á–∏—Å–ª–æ —á–∞—Å—Ç–∏—Ü –≤ —Å–∏—Å—Ç–µ–º–µ,
    # 3 ‚Äî —Ç—Ä–∏ –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ–Ω–Ω—ã–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã: x, y, z.

    for i in range(N):
        for j in range(i + 1, N):
            dx = pos[i, 0] - pos[j, 0]
            dy = pos[i, 1] - pos[j, 1]
            dz = pos[i, 2] - pos[j, 2]
            # –ø—Ä–æ—Å—á–∏—Ç—ã–≤–∞–µ–º —Ä–∞–∑–Ω–æ—Å—Ç—å x/y/z-–∫–æ–æ—Ä–¥–∏–Ω–∞—Ç –º–µ–∂–¥—É i-–æ–π j-–æ–π —á–∞—Å—Ç–∏—Ü–æ–π
            # –≤—ã—Å—á–∏—Ç—ã–≤–∞–µ–º –∫–≤–∞–¥—Ä–∞—Ç —Ä–∞—Å—Å—Ç–æ—è–Ω–∏—è –º–µ–∂–∂—É —Ü–µ–Ω—Ç—Ä–∞–º–∏ —á–∞—Å—Ç–∏—Ü—ã –≤ 3D
            dist_sq = dx * dx + dy * dy + dz * dz

            if dist_sq < (2 * r) ** 2:
                dist = np.sqrt(dist_sq)  # –≤–æ—Ç —Ç—É—Ç –º—ã –∏ –ø–æ—Å—á–∏—Ç–∞–ª–∏ –Ω–∞—Å—Ç–æ—è—â–µ–µ —Ä–∞—Å—Ç–æ—è–Ω–∏–µ
                if dist < 1e-12:
                    continue  # –ø—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –æ–≥—Ä–Ω–∏—á–µ–Ω–∏—è –æ—Ç –∂–µ–ª–µ–∑–∞
                nx, ny, nz = dx / dist, dy / dist, dz / dist  # –µ–¥–µ–Ω–∏—á–Ω—ã–π –Ω–∞–ø—Ä–≤–ª–µ–Ω–Ω—ã–π –≤–µ–∫—Ç–æ—Ä –æ—Ç j –∫ i
                overlap = 2 * r - dist
                pos[j, 0] += nx * overlap
                pos[j, 1] += ny * overlap
                pos[j, 2] += nz * overlap  # —Å–º–µ—â–∞–µ–º j-—É—é —á–∞—Å—Ç–∏—á—É –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ i-–æ–π


ensure_no_overlap(pos, r)

# ===============================================================
#      –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø –°–ö–û–†–û–°–¢–ï–ô –ü–û –ú–ê–ö–°–í–ï–õ–õ–£
# ===============================================================
temperature0 = 1.0  # –∫–∞–∫–∞—è-—Ç–æ –±–µ–∑—Ä–∞–∑–º–µ—Ä–Ω–∞—è —Ç–µ–º–ø–µ—Ä–∞—Ç—É—Ä–∞
sigma = np.sqrt(temperature0 / mass)  # –≠—Ç–æ –≤—ã—á–∏—Å–ª–µ–Ω–∏–µ —Å—Ä–µ–¥–Ω–µ–∫–≤–∞–¥—Ä–∞—Ç–∏—á–Ω–æ–≥–æ –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏—è
# –æ–¥–Ω–æ–π –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã —Å–∫–æ—Ä–æ—Å—Ç–∏ –≤ —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–∏ –ú–∞–∫—Å–≤–µ–ª–ª–∞‚Äì–ë–æ–ª—å—Ü–º–∞–Ω–∞.

vel = np.random.normal(0, sigma, size=(N, 3))
'''–ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç –º–∞—Å—Å–∏–≤ —Å–ª—É—á–∞–π–Ω—ã—Ö —Å–∫–æ—Ä–æ—Å—Ç–µ–π –¥–ª—è –≤—Å–µ—Ö N —á–∞—Å—Ç–∏—Ü.
np.random.normal(loc, scale, size) ‚Äî –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç —á–∏—Å–ª–∞ –∏–∑ –Ω–æ—Ä–º–∞–ª—å–Ω–æ–≥–æ —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è:
loc = 0 ‚Äî –º–∞—Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –æ–∂–∏–¥–∞–Ω–∏–µ (—Å—Ä–µ–¥–Ω–µ–µ –∑–Ω–∞—á–µ–Ω–∏–µ) = 0.
scale = sigma ‚Äî —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–µ –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏–µ.
size=(N, 3) ‚Äî —Å–æ–∑–¥–∞—ë—Ç—Å—è –¥–≤—É–º–µ—Ä–Ω—ã–π –º–∞—Å—Å–∏–≤ N —Å—Ç—Ä–æ–∫ √ó 3 —Å—Ç–æ–ª–±—Ü–∞:
–ö–∞–∂–¥–∞—è —Å—Ç—Ä–æ–∫–∞ ‚Äî –≤–µ–∫—Ç–æ—Ä —Å–∫–æ—Ä–æ—Å—Ç–∏ –æ–¥–Ω–æ–π —á–∞—Å—Ç–∏—Ü—ã: [v_x, v_y, v_z].
–í—Å–µ–≥–æ 3N –Ω–µ–∑–∞–≤–∏—Å–∏–º—ã—Ö —Å–ª—É—á–∞–π–Ω—ã—Ö —á–∏—Å–µ–ª'''

vel -= np.mean(vel, axis=0)  # —É–±–∏—Ä–∞–µ–º –¥—Ä–µ–π—Ñ
'''
np.mean(vel, axis=0) vel ‚Äî –º–∞—Å—Å–∏–≤ —Ñ–æ—Ä–º—ã (N, 3).
axis=0 ‚Äî —Å—Ä–µ–¥–Ω–µ–µ –ø–æ –ø–µ—Ä–≤–æ–π –æ—Å–∏ (–ø–æ —á–∞—Å—Ç–∏—Ü–∞–º), —Ç.–µ. –ø–æ —Å—Ç—Ä–æ–∫–∞–º.
–†–µ–∑—É–ª—å—Ç–∞—Ç ‚Äî –≤–µ–∫—Ç–æ—Ä –¥–ª–∏–Ω—ã 3 vel -= ... –í—ã—á–∏—Ç–∞–µ—Ç —ç—Ç–æ—Ç –≤–µ–∫—Ç–æ—Ä –∏–∑ –∫–∞–∂–¥–æ–π —Å—Ç—Ä–æ–∫–∏ –º–∞—Å—Å–∏–≤–∞ vel
'''


# ===============================================================
#         –£–°–ö–û–†–ï–ù–ù–´–ï –§–£–ù–ö–¶–ò–ò –° JIT (numba)
# ===============================================================

@jit(nopython=True)  # —ç—Ç–æ –ø—Ä–æ—Å—Ç–æ —É—Å–∫–æ—Ä–µ–Ω–∏–µ –∏–¥–µ—Ç –∫–æ–º–ø–∏–ª—è—Ü–∏—è –≤ –º–∞—à–∏–Ω–Ω—ã–π –∫–æ–¥
def step_numba(pos, vel, L, r, mass, dt, momentum):  # momentum —Å—É–º–º–∞—Ä–Ω—ã–π –∏–º–ø—É–ª—å—Å,
    # –ø–µ—Ä–µ–¥–∞–Ω–Ω—ã–π –≤—Å–µ–º —à–µ—Å—Ç–∏ —Å—Ç–µ–Ω–∫–∞–º –∑–∞ –≤—Å—ë –≤—Ä–µ–º—è —Å–∏–º—É–ª—è—Ü–∏–∏

    # --- 1. –î–≤–∏–∂–µ–Ω–∏–µ –º–µ—Ç–æ–¥–æ–º –≠–π–ª–µ—Ä–∞---
    pos += vel * dt

    # --- 2. –û—Ç—Ä–∞–∂–µ–Ω–∏–µ –æ—Ç —Å—Ç–µ–Ω–æ–∫ + –∏–º–ø—É–ª—å—Å ---
    for i in range(pos.shape[0]):
        for axis in range(3):
            if pos[i, axis] < 0:  # –ï—Å–ª–∏ —á–∞—Å—Ç–∏—Ü–∞ —É—à–ª–∞ –∑–∞ –ª–µ–≤—É—é —Å—Ç–µ–Ω–∫—É
                vel[i, axis] *= -1
                pos[i, axis] = 0
                momentum[0] += 2 * mass * abs(vel[i, axis])  # –î–æ–±–∞–≤–ª—è–µ–º –≤ momentum[0] –∏–º–ø—É–ª—å—Å, –ø–µ—Ä–µ–¥–∞–Ω–Ω—ã–π —Å—Ç–µ–Ω–∫–µ

            elif pos[i, axis] > L:
                vel[i, axis] *= -1
                pos[i, axis] = L
                momentum[0] += 2 * mass * abs(vel[i, axis])

    # ---3. –°—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏—è —á–∞—Å—Ç–∏—Ü (O(N¬≤), –Ω–æ JIT-—É—Å–∫–æ—Ä–µ–Ω–æ) ---
    for i in range(pos.shape[0]):
        for j in range(i + 1, pos.shape[0]):
            dx = pos[i, 0] - pos[j, 0]
            dy = pos[i, 1] - pos[j, 1]
            dz = pos[i, 2] - pos[j, 2]
            dist_sq = dx * dx + dy * dy + dz * dz
            d2 = 4 * r * r  # (2r)^2
            # —Å–Ω–æ–≤–∞ –ø–µ—Ä–µ–±–æ—Ä –≤—Å–µ—Ö —á–∞—Å—Ç–∏—Ü
            if dist_sq < d2:
                dist = np.sqrt(dist_sq)

                inv_dist = 1.0 / (dist + 1e-12)
                # –º—ã –∏–∑–±–µ–≥–∞–µ–º –¥–µ–ª–µ–Ω–∏–µ –Ω–∞ 0 –∏ —É—Å–∫–æ—Ä–µ—è–º –∫–æ–¥ —Ç–∞–∫ –∫–∞–∫ –¥–µ–ª–µ–Ω–∏–µ –º–µ–¥–ª–µ–Ω–Ω–µ —É–º–Ω–æ–∂–µ–Ω–∏—è
                nx, ny, nz = dx * inv_dist, dy * inv_dist, dz * inv_dist

                dvx = vel[i, 0] - vel[j, 0]
                dvy = vel[i, 1] - vel[j, 1]
                dvz = vel[i, 2] - vel[j, 2]
                vn = dvx * nx + dvy * ny + dvz * nz

                if vn < 0:  # –¥–≤–∏–∂—É—Ç—Å—è –Ω–∞–≤—Å—Ç—Ä–µ—á—É
                    # –æ–±–Ω–æ–≤–ª—è–µ–º —Å–∫–æ—Ä–æ—Å—Ç–∏ (—É–ø—Ä—É–≥–æ, –æ–¥–∏–Ω–∞–∫–æ–≤—ã–µ –º–∞—Å—Å—ã)

                    vel[i, 0] -= vn * nx
                    vel[i, 1] -= vn * ny
                    vel[i, 2] -= vn * nz

                    vel[j, 0] += vn * nx
                    vel[j, 1] += vn * ny
                    vel[j, 2] += vn * nz

                    # —Ä–∞–∑–¥–≤–∏–≥–∞–µ–º, —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å –∑–∞–ª–∏–ø–∞–Ω–∏—è
                    overlap = 2 * r - dist
                    pos[i, 0] += nx * (overlap * 0.5)
                    pos[i, 1] += ny * (overlap * 0.5)
                    pos[i, 2] += nz * (overlap * 0.5)
                    pos[j, 0] -= nx * (overlap * 0.5)
                    pos[j, 1] -= ny * (overlap * 0.5)
                    pos[j, 2] -= nz * (overlap * 0.5)


# ===============================================================
#                   –≠–¢–ê–ü 1: –†–ê–í–ù–û–í–ï–°–ò–ï
# ===============================================================
momentum = np.array([0.0])  # numba —Ç—Ä–µ–±—É–µ—Ç –º–∞—Å—Å–∏–≤

for step_num in range(steps_eq):
    step_numba(pos, vel, L, r, mass, dt, momentum)
    if step_num % 1000 == 0:
        print(f"Equilibration: {step_num}/{steps_eq}")
# –ü—Ä–æ–≥–æ–Ω —Å–∏—Å—Ç–µ–º—ã –¥–æ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è —Å—Ç–∞—Ü–∏–æ–Ω–∞—Ä–Ω–æ–≥–æ —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è
# –í—ã–≤–æ–¥ –∫–∞–∂–¥—ã–µ 1000 —à–∞–≥–æ–≤ ‚Äî –¥–ª—è –∫–æ–Ω—Ç—Ä–æ–ª—è –ø—Ä–æ–≥—Ä–µ—Å—Å–∞


# –í—ã—á–∏—Å–ª—è–µ–º —Ç–µ–º–ø–µ—Ä–∞—Ç—É—Ä—É
# np.sum(..., axis=1) ‚Äî —Å—É–º–º–∞ –∫–≤–∞–¥—Ä–∞—Ç–æ–≤ –ø–æ –æ—Å—è–º ‚Üí v_i¬≤ –¥–ª—è –∫–∞–∂–¥–æ–π —á–∞—Å—Ç–∏—Ü—ã
# KE ‚Äî –º–∞—Å—Å–∏–≤ –∫–∏–Ω–µ—Ç–∏—á–µ—Å–∫–∏—Ö —ç–Ω–µ—Ä–≥–∏–π —á–∞—Å—Ç–∏—Ü

KE = 0.5 * mass * np.sum(vel ** 2, axis=1)
# –°–≤—è–∑—å —Ç–µ–º–ø–µ—Ä–∞—Ç—É—Ä—ã –∏ —Å—Ä–µ–¥–Ω–µ–π –∫–∏–Ω–µ—Ç–∏—á–µ—Å–∫–æ–π —ç–Ω–µ—Ä–≥–∏–∏ –≤ 3D
T_model = (2 / 3) * np.mean(KE)
print("\nüîπ –¢–µ–º–ø–µ—Ä–∞—Ç—É—Ä–∞:", T_model)

# –î–∞–≤–ª–µ–Ω–∏–µ
# –ò–º–ø—É–ª—å—Å, –ø–µ—Ä–µ–¥–∞–Ω–Ω—ã–π –≤—Å–µ–º 6 —Å—Ç–µ–Ω–∫–∞–º: momentum[0].
# –í—Ä–µ–º—è –º–æ–¥–µ–ª–∏—Ä–æ–≤–∞–Ω–∏—è: T = steps_eq * dt.
# –°—É–º–º–∞—Ä–Ω–∞—è –ø–ª–æ—â–∞–¥—å –≤—Å–µ—Ö —Å—Ç–µ–Ω–æ–∫: 6 * L¬≤ = 6 * area.
# –î–∞–≤–ª–µ–Ω–∏–µ ‚Äî —Å–∏–ª–∞ –Ω–∞ –µ–¥–∏–Ω–∏—Ü—É –ø–ª–æ—â–∞–¥–∏, —Å–∏–ª–∞ ‚Äî –∏–º–ø—É–ª—å—Å –≤ –µ–¥–∏–Ω–∏—Ü—É –≤—Ä–µ–º–µ–Ω–∏:
area = L * L
P_model = momentum[0] / (steps_eq * dt * 6 * area)
P_ideal = N * T_model / (L ** 3)
print("üîπ P_model =", P_model)
print("üîπ P_ideal =", P_ideal)
print("üîπ P_model / P_ideal =", P_model / P_ideal)
print("–û—Ç–Ω–æ—à–µ–Ω–∏–µ >1 ‚Üí —Å–∏—Å—Ç–µ–º–∞ –Ω–µ –∏–¥–µ–∞–ª—å–Ω–∞ –ø–æ —É—Ä–∞–≤–Ω–µ–Ω–∏—é –í–∞–Ω-–¥–µ—Ä-–í–∞–∞–ª—å—Å–∞")

# ===============================================================
#           –≠–¢–ê–ü 2: M7C ‚Äî –§–õ–£–ö–¢–£–ê–¶–ò–ò
# ===============================================================
left_counts = np.empty(steps_stat, dtype=np.int32)
# left_counts ‚Äî –º–∞—Å—Å–∏–≤ –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è k(t): —á–∏—Å–ª–æ —á–∞—Å—Ç–∏—Ü —Å x < L/2 –≤ –∫–∞–∂–¥—ã–π –º–æ–º–µ–Ω—Ç –≤—Ä–µ–º–µ–Ω–∏.
momentum[0] = 0.0  # —Å–±—Ä–æ—Å –∏–º–ø—É–ª—å—Å–∞

print("\nüîπ –°–±–æ—Ä —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ —Ñ–ª—É–∫—Ç—É–∞—Ü–∏–π...")

for i in range(steps_stat):
    step_numba(pos, vel, L, r, mass, dt, momentum)
    left_counts[i] = np.sum(pos[:, 0] < L / 2)
    if i % 1000 == 0:
        print(f"  {i}/{steps_stat}", end='\r')

print(f"\n‚úÖ –°–±–æ—Ä –∑–∞–≤–µ—Ä—à—ë–Ω. –°—Ä–µ–¥–Ω–µ–µ —Å–ª–µ–≤–∞: {left_counts.mean():.1f} / {N / 2}")

# ===============================================================
#       –¢–ï–û–†–ò–Ø + –ì–†–ê–§–ò–ö
# ===============================================================
values = np.arange(0, N + 1)
binom_dist = np.array([comb(N, k) * 0.5 ** N for k in values])

plt.figure(figsize=(10, 5))
hist, _ = np.histogram(left_counts, bins=np.arange(N + 2), density=True)
plt.step(np.arange(N + 1), hist, where='mid', label="3D Simulation", linewidth=2)

plt.plot(values, binom_dist, 'ro-', markersize=3, label="Binomial theory", alpha=0.7)

# –î–æ–±–∞–≤–∏–º –ø–∞—Ä–∞–º–µ—Ç—Ä—ã
mu_th = N / 2
sigma_th = np.sqrt(N / 4)
mu_sim = left_counts.mean()
sigma_sim = left_counts.std()
plt.axvline(mu_th, color='k', linestyle='--', alpha=0.5, label=f"Theory: Œº={mu_th:.0f}, œÉ={sigma_th:.1f}")
plt.axvline(mu_sim, color='b', linestyle=':', alpha=0.7, label=f"Sim: Œº={mu_sim:.1f}, œÉ={sigma_sim:.1f}")
# œÉ - —ç—Ç–æ –º–µ—Ä–∞ —Ä–∞–∑–±—Ä–æ—Å–∞ ‚Äî –Ω–∞—Å–∫–æ–ª—å–∫–æ —Å–∏–ª—å–Ω–æ –∑–Ω–∞—á–µ–Ω–∏—è k –æ—Ç–∫–ª–æ–Ω—è—é—Ç—Å—è –æ—Ç —Å—Ä–µ–¥–Ω–µ–≥–æ.
plt.xlabel("–ß–∏—Å–ª–æ —á–∞—Å—Ç–∏—Ü –≤ –ª–µ–≤–æ–π –ø–æ–ª–æ–≤–∏–Ω–µ")
plt.ylabel("–í–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å")
plt.title(f"–§–ª—É–∫—Ç—É–∞—Ü–∏–∏ —á–∏—Å–ª–∞ —á–∞—Å—Ç–∏—Ü (N={N}, r={r})")
plt.legend()
plt.grid(alpha=0.3)
plt.tight_layout()
plt.show()